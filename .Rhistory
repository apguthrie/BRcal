library(dplyr)
#######################################################
#  Helper Functions - Shouldn't need to change these? #
#######################################################
# Linear Log Odds Recalibration Function
LLO <- function(p, delta, gamma){
return((delta * (p^gamma)) / ((delta * (p^gamma)) + ((1-p)^gamma)))
}
# Converts probs to logit scale
logit <- function(p){
p <- ifelse(p < (10^(-300)), (10^(-300)), p)
p <- ifelse(p > 0.9999999999999999, 0.9999999999999999, p)
return(log(p/(1-p)))
}
# Likelihood
llo_lik <- function(params, x, y, log = FALSE, neg = FALSE){
# rounding off x's that are too close to zero or one
x <- ifelse(x < (10^(-300)), (10^(-300)), x)
x <- ifelse(x > 0.9999999999999999, 0.9999999999999999, x)
llo <- LLO(p = x, delta = params[1], gamma = params[2])
llo <- ifelse(llo < (10^(-300)), (10^(-300)), llo)
llo <- ifelse(llo > 0.9999999999999999, 0.9999999999999999, llo)
if(log){
result <- sum(y * log(llo) + (1 - y) * log(1 - llo))
} else{
result <- prod((llo^y) * (1 - llo)^(1 - y))
}
if(neg){
result <- -result
}
return(result)
}
# Likelihood Ratio Test
LLO_LRT <- function(x, y, params = c(1,1), optim_details = FALSE, start = c(0.5,0.5), lower = c(0.001, -5), upper = c(10,30)){
top <- llo_lik(params, x, y, log = TRUE)
optLRT <- optim(start, llo_lik, x=x, y=y, method = "L-BFGS-B",
lower = lower, upper = upper, neg = TRUE, log = TRUE)
bottom <- -optLRT$value
est_params <- optLRT$par
val <- 2*(bottom-top)
pval <- 1-pchisq(val, 2)
if(optim_details){
results <- list(test_stat = val,
pval = pval,
est_params = est_params,
opt_value = bottom,
opt_counts = optLRT$counts,
opt_convergence = optLRT$convergence,
opt_message = optLRT$message)
} else {
results <- list(test_stat = val,
pval = pval,
est_params = est_params)
}
return(results)
}
# BIC for this likelihood
BIC_llo <- function(x, y, k, params = NA, lower = c(0.001, -5), upper = c(10,30)){
n <- length(x)
if(k == 0){
suppressWarnings(if(is.na(params)) stop("must specify null params when k = 0"))
result <- -2*llo_lik(params = params, x = x, y = y, log = TRUE)
} else if(anyNA(params)){
optBayes <- optim(c(0.5, 0.5), llo_lik, x=x, y=y, log = TRUE, neg = TRUE, method = "L-BFGS-B",
lower = lower, upper = upper)
max_lik <- -optBayes$value
MLEs <- optBayes$par
result <- list(BIC = k * log(n) - (2 * max_lik),
est_params = MLEs)
} else {
result <- list(BIC = k * log(n) - (2 * llo_lik(params = params, x = x, y = y, log = TRUE)),
params = params)
}
return(result)
}
# Bayes factor - only approx BIC version for now
bayes_factor <- function(BIC1, BIC2, approx = TRUE){
return(exp(-(1/2) * (BIC1 - BIC2)))
}
# Posterior model probability
post_mod_prob <- function(BF){
return(1/(1+BF))
}
# Bayesian Calibration assessment function
bayes_testing <- function(x, y, k = 2, params_null = c(1,1), params = NA, optim_details = FALSE, lower = c(0.001, -5), upper = c(10,30)){
# BIC under null
BIC1 <- BIC_llo(x = x, y = y, k = 0, params = params_null, lower = lower, upper = upper)
# BIC under alternative
temp <- BIC_llo(x = x, y = y, k = k, params = params, lower = lower, upper = upper)
BIC2 <- temp$BIC
# Bayes factors
## Likelihood of h0/likelihood of h1
BF12 <- bayes_factor(BIC1 = BIC1, BIC2 = BIC2)
## Likelihood of h1/likelihood of h0
BF21 <- 1/BF12
# Posterior Model Probabilities
## P(cal|data) = P(H0|data)
post1 <- post_mod_prob(BF = BF21)
## P(not cal|data) = P(H1|data)
post2 <- 1-post1
if(anyNA(params)){
est_params <- temp$est_params
results <- list(BIC_H0 = BIC1,
BIC_H1 = BIC2,
BF = BF21,
posterior_model_prob = post1,
est_params = est_params)
} else{
results <- list(BIC_H0 = BIC1,
BIC_H1 = BIC2,
BF = BF21,
posterior_model_prob = post1,
params = params)
}
return(results)
}
# Function to make contour plot
plot_params <- function(z, len.out = 100,
lower = c(0.0001,-2), upper = c(5,2),
cont_levels = c(0.8, 0.9),
sub = "",
zlim = c(0,1),
ttle_extra = "",
ttle = "Posterior Model Probability of Calibration",
contours_only = FALSE,
add = FALSE,
contour_color = "white",
leg_lab = "",
drawlabels = TRUE,
xlab = "delta",
ylab = "gamma",
lwd=1,
labcex=0.6,
legend.args = list(las=180),
...){
library(fields)
max_z <- max(z[!is.na(z)])
if(anyNA(lower)){
lower <- c(min(d), min(g))
}
if(anyNA(upper)){
upper <- c(max(d), max(g))
}
g <- as.numeric(colnames(z))
d <- as.numeric(rownames(z))
if(!contours_only){
image.plot(d, g, z, zlim = zlim, xlim = c(lower[1], upper[1]), ylim = c(lower[2], upper[2]),
main = paste0(ttle, ttle_extra),
xlab = xlab,
ylab = ylab,
sub = sub,
legend.mar = 9,
legend.lab = leg_lab,
legend.args = legend.args, ...)
if(!anyNA(cont_levels)){
contour(d, g, z, add = TRUE, levels = cont_levels, col = contour_color,
drawlabels = drawlabels, lwd=lwd, labcex=labcex)
}
}else{
if(!anyNA(cont_levels)){
contour(d, g, z, add = add, levels = cont_levels, col = contour_color,
zlim = zlim, xlim = c(lower[1], upper[1]), ylim = c(lower[2], upper[2]),
main = paste0(ttle, ttle_extra),
xlab = xlab,
ylab = ylab,
sub = sub, drawlabels = drawlabels, lwd=lwd, labcex=labcex, ...)
} else {
stop("must provide contour levels")
}
}
}
#############################################
#  Boldness-Recalibration Code starts here  #
#############################################
# Function to get matrix of posterior model probabilities across delta/gamma grid
get_zmat <- function(x,y, len.out = 100, lower = c(0.0001,-2), upper = c(5,2)){
# Set up grid of Delta (d) and Gamma (g)
d <- seq(lower[1], upper[1], length.out = len.out)
g <- seq(lower[2], upper[2], length.out = len.out)
grd <- expand.grid(d,g)
# Loop through grid points to get posterior model probability
temp <- c()
for(i in 1:nrow(grd)){
x_new <- LLO(x, delta = grd[i,1], gamma = grd[i,2])   # LLO adjust probs FIRST based on grid point
pmp <- bayes_testing(x_new, y)$posterior_model_prob   # Get posterior model prob
temp <- c(temp, pmp)
}
# Reshape vector of posterior model probs into matrix for plotting
z_mat <- matrix(temp, nrow = length(d), ncol = length(g))
colnames(z_mat) <- g
rownames(z_mat) <- d
return(z_mat)
}
# Load FiveThirtyEight data
original538 <- read.csv("../../hockey/data/compiled_NHL_pundit_data20_21_FULL.csv",
row.names=1, stringsAsFactors=TRUE) %>%
transmute(y = Winner01,
x = HomeProb538)
# Set upper and lower bounds for delta/gamma grid search
lower = c(0.6, -0.5)
upper = c(1.5, 2.25)
# Set fineness of grid
# k * k = # of grid points
# bigger k = slower
# We used k=200 for manuscript, k=10 is fast for development
k <- 10
# Get matrix of posterior model probabilities across grid
zmat <- get_zmat(original538$x, original538$y, len.out=10, lower = lower, upper = upper)
setwd("C:/Users/apgut/Documents/ppc/writing/LLO_paper")
setwd("C:/Users/apgut/Documents/ppc/writing/LLO_paper")
library(dplyr)
#######################################################
#  Helper Functions - Shouldn't need to change these? #
#######################################################
# Linear Log Odds Recalibration Function
LLO <- function(p, delta, gamma){
return((delta * (p^gamma)) / ((delta * (p^gamma)) + ((1-p)^gamma)))
}
# Converts probs to logit scale
logit <- function(p){
p <- ifelse(p < (10^(-300)), (10^(-300)), p)
p <- ifelse(p > 0.9999999999999999, 0.9999999999999999, p)
return(log(p/(1-p)))
}
# Likelihood
llo_lik <- function(params, x, y, log = FALSE, neg = FALSE){
# rounding off x's that are too close to zero or one
x <- ifelse(x < (10^(-300)), (10^(-300)), x)
x <- ifelse(x > 0.9999999999999999, 0.9999999999999999, x)
llo <- LLO(p = x, delta = params[1], gamma = params[2])
llo <- ifelse(llo < (10^(-300)), (10^(-300)), llo)
llo <- ifelse(llo > 0.9999999999999999, 0.9999999999999999, llo)
if(log){
result <- sum(y * log(llo) + (1 - y) * log(1 - llo))
} else{
result <- prod((llo^y) * (1 - llo)^(1 - y))
}
if(neg){
result <- -result
}
return(result)
}
# Likelihood Ratio Test
LLO_LRT <- function(x, y, params = c(1,1), optim_details = FALSE, start = c(0.5,0.5), lower = c(0.001, -5), upper = c(10,30)){
top <- llo_lik(params, x, y, log = TRUE)
optLRT <- optim(start, llo_lik, x=x, y=y, method = "L-BFGS-B",
lower = lower, upper = upper, neg = TRUE, log = TRUE)
bottom <- -optLRT$value
est_params <- optLRT$par
val <- 2*(bottom-top)
pval <- 1-pchisq(val, 2)
if(optim_details){
results <- list(test_stat = val,
pval = pval,
est_params = est_params,
opt_value = bottom,
opt_counts = optLRT$counts,
opt_convergence = optLRT$convergence,
opt_message = optLRT$message)
} else {
results <- list(test_stat = val,
pval = pval,
est_params = est_params)
}
return(results)
}
# BIC for this likelihood
BIC_llo <- function(x, y, k, params = NA, lower = c(0.001, -5), upper = c(10,30)){
n <- length(x)
if(k == 0){
suppressWarnings(if(is.na(params)) stop("must specify null params when k = 0"))
result <- -2*llo_lik(params = params, x = x, y = y, log = TRUE)
} else if(anyNA(params)){
optBayes <- optim(c(0.5, 0.5), llo_lik, x=x, y=y, log = TRUE, neg = TRUE, method = "L-BFGS-B",
lower = lower, upper = upper)
max_lik <- -optBayes$value
MLEs <- optBayes$par
result <- list(BIC = k * log(n) - (2 * max_lik),
est_params = MLEs)
} else {
result <- list(BIC = k * log(n) - (2 * llo_lik(params = params, x = x, y = y, log = TRUE)),
params = params)
}
return(result)
}
# Bayes factor - only approx BIC version for now
bayes_factor <- function(BIC1, BIC2, approx = TRUE){
return(exp(-(1/2) * (BIC1 - BIC2)))
}
# Posterior model probability
post_mod_prob <- function(BF){
return(1/(1+BF))
}
# Bayesian Calibration assessment function
bayes_testing <- function(x, y, k = 2, params_null = c(1,1), params = NA, optim_details = FALSE, lower = c(0.001, -5), upper = c(10,30)){
# BIC under null
BIC1 <- BIC_llo(x = x, y = y, k = 0, params = params_null, lower = lower, upper = upper)
# BIC under alternative
temp <- BIC_llo(x = x, y = y, k = k, params = params, lower = lower, upper = upper)
BIC2 <- temp$BIC
# Bayes factors
## Likelihood of h0/likelihood of h1
BF12 <- bayes_factor(BIC1 = BIC1, BIC2 = BIC2)
## Likelihood of h1/likelihood of h0
BF21 <- 1/BF12
# Posterior Model Probabilities
## P(cal|data) = P(H0|data)
post1 <- post_mod_prob(BF = BF21)
## P(not cal|data) = P(H1|data)
post2 <- 1-post1
if(anyNA(params)){
est_params <- temp$est_params
results <- list(BIC_H0 = BIC1,
BIC_H1 = BIC2,
BF = BF21,
posterior_model_prob = post1,
est_params = est_params)
} else{
results <- list(BIC_H0 = BIC1,
BIC_H1 = BIC2,
BF = BF21,
posterior_model_prob = post1,
params = params)
}
return(results)
}
# Function to make contour plot
plot_params <- function(z, len.out = 100,
lower = c(0.0001,-2), upper = c(5,2),
cont_levels = c(0.8, 0.9),
sub = "",
zlim = c(0,1),
ttle_extra = "",
ttle = "Posterior Model Probability of Calibration",
contours_only = FALSE,
add = FALSE,
contour_color = "white",
leg_lab = "",
drawlabels = TRUE,
xlab = "delta",
ylab = "gamma",
lwd=1,
labcex=0.6,
legend.args = list(las=180),
...){
library(fields)
max_z <- max(z[!is.na(z)])
if(anyNA(lower)){
lower <- c(min(d), min(g))
}
if(anyNA(upper)){
upper <- c(max(d), max(g))
}
g <- as.numeric(colnames(z))
d <- as.numeric(rownames(z))
if(!contours_only){
image.plot(d, g, z, zlim = zlim, xlim = c(lower[1], upper[1]), ylim = c(lower[2], upper[2]),
main = paste0(ttle, ttle_extra),
xlab = xlab,
ylab = ylab,
sub = sub,
legend.mar = 9,
legend.lab = leg_lab,
legend.args = legend.args, ...)
if(!anyNA(cont_levels)){
contour(d, g, z, add = TRUE, levels = cont_levels, col = contour_color,
drawlabels = drawlabels, lwd=lwd, labcex=labcex)
}
}else{
if(!anyNA(cont_levels)){
contour(d, g, z, add = add, levels = cont_levels, col = contour_color,
zlim = zlim, xlim = c(lower[1], upper[1]), ylim = c(lower[2], upper[2]),
main = paste0(ttle, ttle_extra),
xlab = xlab,
ylab = ylab,
sub = sub, drawlabels = drawlabels, lwd=lwd, labcex=labcex, ...)
} else {
stop("must provide contour levels")
}
}
}
#############################################
#  Boldness-Recalibration Code starts here  #
#############################################
# Function to get matrix of posterior model probabilities across delta/gamma grid
get_zmat <- function(x,y, len.out = 100, lower = c(0.0001,-2), upper = c(5,2)){
# Set up grid of Delta (d) and Gamma (g)
d <- seq(lower[1], upper[1], length.out = len.out)
g <- seq(lower[2], upper[2], length.out = len.out)
grd <- expand.grid(d,g)
# Loop through grid points to get posterior model probability
temp <- c()
for(i in 1:nrow(grd)){
x_new <- LLO(x, delta = grd[i,1], gamma = grd[i,2])   # LLO adjust probs FIRST based on grid point
pmp <- bayes_testing(x_new, y)$posterior_model_prob   # Get posterior model prob
temp <- c(temp, pmp)
}
# Reshape vector of posterior model probs into matrix for plotting
z_mat <- matrix(temp, nrow = length(d), ncol = length(g))
colnames(z_mat) <- g
rownames(z_mat) <- d
return(z_mat)
}
# Load FiveThirtyEight data
original538 <- read.csv("../../hockey/data/compiled_NHL_pundit_data20_21_FULL.csv",
row.names=1, stringsAsFactors=TRUE) %>%
transmute(y = Winner01,
x = HomeProb538)
# Set upper and lower bounds for delta/gamma grid search
lower = c(0.6, -0.5)
upper = c(1.5, 2.25)
# Set fineness of grid
# k * k = # of grid points
# bigger k = slower
# We used k=200 for manuscript, k=10 is fast for development
k <- 10
# Get matrix of posterior model probabilities across grid
zmat <- get_zmat(original538$x, original538$y, len.out=10, lower = lower, upper = upper)
# Set t (level of desired calibration)
calib <- 0.95
inds1 <- which(zmat >= calib, arr.ind = TRUE) # looks at anything greater or equal to 0.9
# Set up storage
adj_res <- data.frame(delta = vector(length = nrow(inds1)),
gamma = vector(length = nrow(inds1)),
post = vector(length = nrow(inds1)),
sd = vector(length = nrow(inds1)))
# Loop through delta/gamma grid to extract delta/gamma values for which calibration constraint is satisfied
for(i in 1:nrow(inds1)){
adj_res$post[i] <- zmat[inds1[i,1], inds1[i,2]]
adj_res$delta[i] <- rownames(zmat)[inds1[i,1]]
adj_res$gamma[i] <- colnames(zmat)[inds1[i,2]]
}
adj_res$delta <- as.numeric(adj_res$delta)
adj_res$gamma <- as.numeric(adj_res$gamma)
# Loop through candidate delta/gamma pairs to get standard deviations
for(i in 1:nrow(adj_res)){
temp <- LLO(original538$x, delta = adj_res$delta[i], gamma = adj_res$gamma[i])
adj_res$sd[i] <- sd(temp)
}
# Get index for max boldness
indmax <- which.max(adj_res$sd)
# Show delta, gamma with max boldness given pr calib >= 0.95
adj_res[indmax,]
# B-R Contour plot
contours <- c(0.95, 0.9, 0.8)
plot_params(zmat, lower = lower, upper = upper,
cont_levels = contours,
ttle = "",
xlab=expression("Shift Parameter " ~ delta),
ylab=expression("Scale Parameter " ~ gamma),
lwd=4, labcex=2,  cex.axis=2,
cex.lab=2, legend.cex=2, axis.args=list(cex.axis=2))
points(x=adj_res[indmax,"delta"], y=adj_res[indmax,"gamma"], pch=20, col="white", cex=2)
bayes_testing(x,y,params=c(2,2))
bayes_testing(original538$x,original538$
y,params=c(2,2))
x <- original538$x
y <- original538$y
BIC_llo(x,y,0,c(1,1),lower=lower,upper=upper)
BIC_llo(x,y,0,c(1,1,2),lower=lower,upper=upper)
BIC_llo(x,y,0,Na,lower=lower,upper=upper)
BIC_llo(x,y,0,NA,lower=lower,upper=upper)
?is.na
# BIC for this likelihood
BIC_llo <- function(x, y, k, params = NA, lower = c(0.001, -5), upper = c(10,30)){
n <- length(x)
if(k == 0){
#suppressWarnings(if(is.na(params)) stop("must specify null params when k = 0"))
suppressWarnings(if(anyNA(params)) stop("must specify null params when k = 0"))
result <- -2*llo_lik(params = params, x = x, y = y, log = TRUE)
} else if(anyNA(params)){
optBayes <- optim(c(0.5, 0.5), llo_lik, x=x, y=y, log = TRUE, neg = TRUE, method = "L-BFGS-B",
lower = lower, upper = upper)
max_lik <- -optBayes$value
MLEs <- optBayes$par
result <- list(BIC = k * log(n) - (2 * max_lik),
est_params = MLEs)
} else {
result <- list(BIC = k * log(n) - (2 * llo_lik(params = params, x = x, y = y, log = TRUE)),
params = params)
}
return(result)
}
BIC_llo(x,y,0,NA,lower=lower,upper=upper)
BIC_llo(x,y,0,c(1,1),lower=lower,upper=upper)
BIC_llo(x,y,0,c(1,1,2),lower=lower,upper=upper)
devtools::dev_sitrep()
#> ── R ───────────────────────────────────────────────────────────────────────
#> • version: 4.1.2
#> • path: '/Library/Frameworks/R.framework/Versions/4.1/Resources/'
#> ── RStudio ─────────────────────────────────────────────────────────────────
#> • version: 2022.2.0.443
#> ── devtools ────────────────────────────────────────────────────────────────
#> • version: 2.4.3.9000
#> • devtools or its dependencies out of date:
#>   'gitcreds', 'gh'
#>   Update them with `devtools::update_packages("devtools")`
#> ── dev package ─────────────────────────────────────────────────────────────
#> • package: 'rpkgs'
#> • path: '/Users/jenny/rrr/r-pkgs/'
#> • rpkgs dependencies out of date:
#>   'gitcreds', 'generics', 'tidyselect', 'dplyr', 'tidyr', 'broom', 'gh'
#>  Update them with `devtools::install_dev_deps()`
library(BRcal)
